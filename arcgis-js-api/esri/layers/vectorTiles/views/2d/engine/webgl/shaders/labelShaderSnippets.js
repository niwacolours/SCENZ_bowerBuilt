//>>built
require({cache:{"url:esri/layers/vectorTiles/views/2d/engine/webgl/shaders/labelShaders.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\n\x3c!--\n  Add your GLSL snippets to this file. You should start from\n  importing your old GLSL files. For instance, if you have a\n  file such as myShader.vs.glsl you should create a new \x3csnippet name\x3d"myShaderVS"\x3e\n  and then copy and paste the GLSL source as the content. You will then convert your\n  code to use the {@link esri/views/2d/engine/webgl/glShaderSnippets glShaderSnippets}\n  instance to access the GLSL code, instead of importing it directly with require("dojo/text!...").\n--\x3e\n\x3csnippets\x3e\n\n  \x3csnippet name\x3d"labelVS"\x3e\n  \x3c![CDATA[\n    precision mediump float;\n\n      attribute vec2 a_pos;                  // 2 * 2 (2 x signed 16)\n      attribute vec4 a_color;                // 4 (4 x unsigned byte)\n      attribute vec2 a_vertexOffset;         // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\n      attribute vec4 a_texAndSize;          // 4 (4 x unsigned byte) texture coordinatesm and font size. w is for the halo size\n      attribute vec4 a_refSymbolAndPlacementOffset; // 4 (4 x unsigned byte) the offset of the reference symbol of the feature (x,y) and the placement offset (z, w) all given in pixels\n\n      attribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n      attribute mediump vec2 a_visibilityRange; // 2 x unsigned byte;\n\n      // the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n      // relative to the tile\'s upper left corner\n      // the extrusion vector.\n      uniform highp mat4 u_transformMatrix;\n      // the extrude matrix which is responsible for the \'anti-zoom\' as well as the rotation\n      uniform highp mat4 u_extrudeMatrix;\n      // u_normalized_origin is the tile\'s upper left corner given in normalized coordinates\n      uniform highp vec2 u_normalized_origin;\n      // the size of the mosaic given in pixels\n      uniform vec2 u_mosaicSize;\n      uniform float u_pixelRatio;\n\n      // the opacity of the layer\n      uniform mediump float u_opacity;\n\n      // the curent zoom\n      uniform mediump float u_zoomLevel; // the current zoom level X 10\n      uniform lowp float u_mapRotation;\n      uniform lowp float u_mapAligned;\n\n      varying mediump float v_antialiasingWidth;\n      varying mediump float v_edgeDistanceOffset;\n\n      // the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\n      varying mediump vec2 v_tex;\n      // the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n      // opacity of the layer given by the painter\n      varying lowp float v_transparency;\n\n    #ifdef ID\n       uniform mediump float u_fadeStep;\n       varying mediump float v_fadeStep;\n    #else\n       varying mediump vec4 v_color;\n    #endif // ID\n\n      // the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n      // by 16 and then at the shader devide by the same number\n      const float offsetPrecision \x3d 1.0 / 8.0;\n      const float outlineScale \x3d 1.0 / 10.0;\n      const float sdfFontSize \x3d 24.0;\n\n      // maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n      // 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\n      const float maxSdfDistance \x3d 8.0;\n\n      const float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\n\n      void main()\n      {\n        // make sure to clip the vertices in case that given record is marked as invisible\n        float z \x3d 2.0 * (1.0 - a_visible);\n\n        // clip the vertex if we are beyond the visibility range of the vertex\n        // please note: min value of 0 is regarded infinity. max value of 255 is regarded infinity\n        z +\x3d 1.0 + sign(a_visibilityRange.x - u_zoomLevel);\n        z +\x3d 1.0 + sign(u_zoomLevel - a_visibilityRange.y);\n\n        // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\n        mediump float halo \x3d mod(a_pos, 2.0).x;\n\n        float fontSize \x3d a_texAndSize.z;\n\n        float fontScale \x3d fontSize / sdfFontSize;\n        // we need to scale the extrude matrix by the font-scale in order to get the right text size\n        mat4 extrudeMatrix \x3d fontScale * u_extrudeMatrix;\n\n        float mapRotation \x3d u_mapAligned * C_DEG_TO_RAD * -u_mapRotation;\n        float sinA \x3d sin(mapRotation);\n        float cosA \x3d cos(mapRotation);\n\n        mat4 mapRotationMat \x3d mat4(cosA, sinA, 0.0, 0.0,\n                                  -sinA, cosA, 0.0, 0.0,\n                                    0.0,  0.0, 1.0, 0.0,\n                                    0.0,  0.0, 0.0, 1.0);\n\n        vec4 refSymbolOffset \x3d mapRotationMat *  vec4(a_refSymbolAndPlacementOffset.xy, 0.0, 0.0);\n\n        gl_Position \x3d vec4(u_normalized_origin, 0.0, 0.0) +\n                      u_transformMatrix * vec4(floor(a_pos * 0.5), z, 1.0) +\n                      u_extrudeMatrix * vec4(refSymbolOffset.xy + a_refSymbolAndPlacementOffset.zw, 0.0, 0.0) +\n                      extrudeMatrix * vec4(offsetPrecision * a_vertexOffset, 0.0, 0.0);\n\n        v_tex \x3d a_texAndSize.xy / u_mosaicSize;\n        v_antialiasingWidth \x3d 0.106 * sdfFontSize / fontSize / u_pixelRatio;\n        // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n        v_edgeDistanceOffset \x3d halo * outlineScale * a_texAndSize.w / fontScale / maxSdfDistance;\n\n        v_transparency \x3d u_opacity;\n\n      #ifdef ID\n        v_fadeStep \x3d u_fadeStep;\n      #else\n        v_color \x3d a_color;\n      #endif // ID\n      }\n  ]]\x3e\n  \x3c/snippet\x3e\n\n  \x3csnippet name\x3d"labelFS"\x3e\n   \x3c![CDATA[\n      precision lowp float;\n\n      uniform mediump sampler2D u_referenceTex;\n      uniform mediump vec2 u_screenSize;\n      uniform mediump float u_pixelRatio;\n\n      varying mediump float v_antialiasingWidth;\n      varying mediump float v_edgeDistanceOffset;\n      varying mediump vec2 v_tex;\n      varying lowp float v_transparency;\n\n    #ifdef ID\n      varying mediump float v_fadeStep;\n    #else\n      uniform lowp sampler2D u_texture;\n      varying mediump vec4 v_color;\n    #endif // ID\n\n    const vec3 epsilon \x3d vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\n      void main()\n      {\n        mediump vec2 refTextPos \x3d gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n        mediump vec4 referenceFragment \x3d texture2D(u_referenceTex, refTextPos);\n    #ifdef ID\n        mediump float alpha \x3d clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n        // fill the whole quad\n        gl_FragColor \x3d vec4(alpha);\n    #else\n        // read the fade alpha\n        lowp float fadeAlpha \x3d referenceFragment.a;\n\n        // read the distance from the SDF texture\n        lowp float dist \x3d texture2D(u_texture, v_tex).a;\n\n        // the edge distance if a factor of the outline width\n        float glyphEdgeDistance \x3d 0.75 - v_edgeDistanceOffset;\n\n        // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n        lowp float sdfAlpha \x3d smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n        gl_FragColor \x3d fadeAlpha * sdfAlpha * v_transparency * v_color;\n    #endif\n      }\n   ]]\x3e\n  \x3c/snippet\x3e\n\x3c/snippets\x3e\n\n'}});
define(["require","exports","dojo/text!./labelShaders.xml","../../../../webgl/ShaderSnippets"],function(a,d,c,b){a=new b;return b.parse(c,a),a});